{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/parallel-computing-and-the-key-for-improving-mapping","result":{"data":{"mdx":{"frontmatter":{"title":"Parallel Computing And The Key For Improving Mapping","category":"robotics","date":"January 24th, 2021","image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAeABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwH/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQP/2gAMAwEAAhADEAAAAYF2wo4KRU5Xzs9HMNv/xAAaEAACAwEBAAAAAAAAAAAAAAABAgAREgMh/9oACAEBAAEFAngIK0JmZhEHhvPXFzrSKqROi1//xAAXEQEBAQEAAAAAAAAAAAAAAAAAERIB/9oACAEDAQE/Ac1lxH//xAAYEQEBAAMAAAAAAAAAAAAAAAABABAREv/aAAgBAgEBPwHaXWFb/8QAHxAAAQMDBQAAAAAAAAAAAAAAAAERMRAhQQJRYYGh/9oACAEBAAY/Ar4GSicixSIFI9GzuLqUu/R//8QAHBABAAMBAAMBAAAAAAAAAAAAAQARIUExYXFR/9oACAEBAAE/IXiatzksh9j637HWjXWflgayGOJLDxpYup4fJKVYOrLXlQ60077gFS99T//aAAwDAQACAAMAAAAQH+1//8QAGREAAgMBAAAAAAAAAAAAAAAAAAERITFx/9oACAEDAQE/EIJZ2M9EkWz/xAAYEQADAQEAAAAAAAAAAAAAAAAAAREhcf/aAAgBAgEBPxCzDgaKnEf/xAAgEAEAAgIBBQEBAAAAAAAAAAABABEhMUFRYZHB8XHw/9oACAEBAAE/EGWKZMv5cVEyquh2mGagLtnxNZvLsvrZFl9ibfJTUFcL7mNIxCrf1gXZVEpsZQ5RoBXbMJOrmBbvwS+60sbXoz8jkVJAADgn/9k=","aspectRatio":0.6666666666666666,"src":"/static/c30a85952e2a780f4bc1f7e70c611f1e/0f3a1/pparallel-2.jpg","srcSet":"/static/c30a85952e2a780f4bc1f7e70c611f1e/f836f/pparallel-2.jpg 200w,\n/static/c30a85952e2a780f4bc1f7e70c611f1e/2244e/pparallel-2.jpg 400w,\n/static/c30a85952e2a780f4bc1f7e70c611f1e/0f3a1/pparallel-2.jpg 500w","sizes":"(max-width: 500px) 100vw, 500px"}}}},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Parallel Computing And The Key For Improving Mapping\",\n  \"slug\": \"parallel-computing-and-the-key-for-improving-mapping\",\n  \"image\": \"./images/pparallel-2.jpeg\",\n  \"date\": \"2021-01-24T00:00:00.000Z\",\n  \"author\": \"emanuele raggi\",\n  \"category\": \"robotics\",\n  \"readTime\": 10\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When developing desktop or mobile applications, especially if a certain degree of detail is required, it can take an exceptional amount of time, especially in tasks such as 1) showing a detailed seafloor map with a lot of features, 2) processing hundreds of images per second trying to rebuild a 3D image real-time, or 3) simply parsing an API response from a web application it can take a conspicuous amount of time. Of course the more detailed the final product must be the more processing power is required. Additional time may not be an option depending on the situation.\"), mdx(\"p\", null, \"To put it simply, how much time are you willing (or able) to spend on a great product? How much depth can you get to provide a high feature map? The most important component is availability of computing power and external memory size, notoriously known as RAM. How can you make an extremely accurate seafloor map if you have the right data available? There are different techniques that can be used from optimizing the use of memory of your computer, meaning squeezing up to the last available byte, but there are cases where this is not helpful enough, actually not even close, especially if the goal is real-time processing.\"), mdx(\"p\", null, \"A valuable alternative is opting for more powerful architecting compilers and or libraries such as OpenMP or OpenAC. Those tools can provide specific directives on how to interact with the processor of your machine making the processing time much faster than your regular machine. Search algorithm performance can significantly improve the outcomes and is very efficient. Depending on the processor available on your computer, there are also specific coding directives that can be used to establish 1) when a specific operation or computing loop has to start and finish or 2) a specific loop can start processing only when another specific loop finishes establishing some sore of priority in the implementation of the operations.\"), mdx(\"p\", null, \"But maybe this is still not enough and you need an even better and quicker processing time and a better efficiency to what was discussed so far. Well, it is time then to talk about CUDA core available on the latest GPU cards typically mounted inside tower desktops or even your laptop. Those act directly on the graphics performance of the system taking the computation load off of the processor and allotting it to the graphical processing unit. If your machines have available slots for GPU cards then it is possible to talk about parallelization or parallel computing. Only remember that when Processors have reached maximum clock speed, the only way to get more out of CPUs is with parallelism.\"), mdx(\"p\", null, \"However it is important to be careful about the difference between parallel computing and multithreading. So:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Parallel programming is the process of using a set of resources to solve a problem in less time by dividing the work\\n-- \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.perforce.com/blog/qac/multithreading-parallel-programming-c-cpp\"\n  }, \"Source\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Multithreading specifically refers to the concurrent execution of more than one sequential set (thread) of instructions.\\nMultithreaded programming is programming multiple, concurrent execution threads. These threads could run on a single processor. Or there could be multiple threads running on multiple processor cores\\n-- \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.perforce.com/blog/qac/multithreading-parallel-programming-c-cpp\"\n  }, \"Source\"))), mdx(\"h4\", null, \"Concurrent vs Parallel: Multithreaded Programming on a Single Processor\"), mdx(\"blockquote\", {\n    display: \"warning\"\n  }, \"Concurrent vs Parallel: Multithreaded Programming on a Single Processor\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Multithreading on a single processor gives the illusion of running in\\nparallel. In reality, the processor is switching by using a scheduling\\nalgorithm. Or, it\\u2019s switching based on a combination of external inputs\\n(interrupts) and how the threads have been prioritized\\n-- \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.perforce.com/blog/qac/multithreading-parallel-programming-c-cpp\"\n  }, \"Source\"))), mdx(\"h4\", null, \"Concurrent vs Parallel: Multithreaded Programming on Multiple Processors\"), mdx(\"blockquote\", {\n    display: \"warning\"\n  }, \"Concurrent vs Parallel: Multithreaded Programming on Multiple Processors\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Multithreading on multiple processor cores is truly parallel. Individual\\nmicroprocessors work together to achieve the result more efficiently. There\\nare multiple parallel, concurrent tasks happening at once. Multithreading\\nallows a single processor to spawn multiple, concurrent threads. Each thread\\nruns its own sequence of instructions. They all access the same shared memory\\nspace and communicate with each other if necessary. The threads can be\\ncarefully managed to optimize performance\\n-- \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.perforce.com/blog/qac/multithreading-parallel-programming-c-cpp\"\n  }, \"Source\"))), mdx(\"h4\", null, \"Parallelism Is Important For AI\"), mdx(\"blockquote\", {\n    display: \"warning\"\n  }, \"Parallelism Is Important For AI\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"As we reach the limits of what can be done on a single processor, more tasks\\nare run on multiple processor cores. This is particularly important for AI.\\nOne example of this is autonomous driving. In a traditional car, humans are\\nrelied upon to make quick decisions. And the average reaction time for humans\\nis 0.25 seconds. So, within autonomous vehicles, AI needs to make these\\ndecisions very quickly \\u2014 in tenths of a second.\\n-- \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.perforce.com/blog/qac/multithreading-parallel-programming-c-cpp\"\n  }, \"Source\"))), mdx(\"p\", null, \"The most common and useful techniques would be:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u2611\", \" \", mdx(\"span\", {\n    style: {\n      \"color\": \"hsl(245, 57%, 50%)\"\n    }\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"SIMD - Single Instruction Multiple Data (multitasking on single core / vector mathematics)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u2611\", \" \", mdx(\"span\", {\n    style: {\n      \"color\": \"hsl(245, 57%, 50%)\"\n    }\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Threads (hyperthreading, multiple cpu cores)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u2611\", \" \", mdx(\"span\", {\n    style: {\n      \"color\": \"hsl(245, 57%, 50%)\"\n    }\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Offloading (OpenMP, OpenACC, CUDA)\")))), mdx(\"br\", null), mdx(\"p\", null, \"Without entering in the details of the methodologies introduced, which I will cover in upcoming posts, it is safe to say that in order to have the best performance, especially for a high demanding customer, in the underwater or dredging field, it would be better to use available CUDA cores. If someone is trying to achieve a structure from motion reconstruction, which has the capability of building real-time a 3D object by evaluating its geometric shapes from different directions and combining the features of interests into a final 3d object, it would be best to use CUDA cores, and is even better to have a couple of the cards working in parallel for best results.\"), mdx(\"p\", null, \"If trying to set up a high fidelity simulation of a robotic system such as a car approaching a target or even real time distance measurement from two different objects, it would be enough to have a powerful machine for which multithreading can be applied.\"), mdx(\"p\", null, \"If trying to 1) foresee the trajectory and lineage of a underwater robot, 2) locate its position in case of loss of signal, and 3) post-process all the data right after the mission, it would be better to use a multithreaded environment and only use 2D approximation if the trajectory and position are known until the point of lost contact. If every position is represented with 3D particle time and there are thousands of particles there will inevitably be a computing problem because there will not be enough power to process the request. That is when CUDA architectures and the latest technology will come into play, taking the load off of the CPU and dividing it in various processes. In this way it is possible to generate a good approximation of the potential recovery point.\"), mdx(\"p\", null, \"It is worth mentioning that this technique can be applied in the medical field as well when trying to foresee the trajectory and lineage of the cells or bacteria for particular types of studies. Results have been promising for cells that move slowly, but it is difficult to track cells that move quickly, and has negatively impacted the overall results.\"), mdx(\"blockquote\", {\n    display: \"info\"\n  }, \"Quote of the week:\"), mdx(\"blockquote\", null, \"Less than 10% of the code has to do with the ostensible purpose of the system. The rest deals with input-output, data validation, data structure maintenance, and other housekeeping \\u2013 Mary Shaw\"), mdx(\"p\", null, \"Stay tuned for the next episode!\"), mdx(Link, {\n    to: \"/posts\",\n    className: \"btn center-btn\",\n    mdxType: \"Link\"\n  }, \"to posts\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"parallel-computing-and-the-key-for-improving-mapping"}},"staticQueryHashes":["2045628104","3227429775","3419630913","3824322444"]}